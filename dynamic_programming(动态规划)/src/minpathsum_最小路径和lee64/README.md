# MinPathSum(最小路径和leeCode64题)

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-path-sum

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。


解题步骤：

第一步：定义数组的含义，即保存了什么样的记录。

本题定义数组为dp[m][n]表示到达dp[i][j]时的最小路径和。

第二步：找出关系式，即历史记录之间的联系。

本题要求从左上角到右下角的路径，使得路径上的数字总和为最小，题目规定每次只能向下或者向右移动一步，
所以只能从(i-1,j)或(i,j-1)的位置到达(i,j)，而到达(i-1,j)的最小路径和为dp[i-1,j]，到达(i,j-1)的最小路径和为dp[i,j-1]。
因此：dp[i][j]=min(dp[i-1][j],dp[i][j-1])+array[i][j]。


第三步：确定初始值和边界。
首先，我们要保证式子不会出现数组越界的问题，所以得保证i和j都大于0。因此，得确定i和j为0时的值。
而当i=0或j=0时，只能往右或往下走，所以此时dp[0][j]=dp[0][j-1]+array[0][j];dp[i][0]=dp[i-1][0]+array[i-1][0];
dp[0][0]=array[0][0]

PS：该题给出的是m行n列，所以最后应该返回dp[m-1][n-1]
题解请参考Solution
该题同uniquepaths一样可改为使用一维数组来优化空间，题解请参考Solution2;
因为原数组就是二维数组，也可以采用原数组来减少空间占用，此时空间复杂度为O(1),题解请参考Solution3;
